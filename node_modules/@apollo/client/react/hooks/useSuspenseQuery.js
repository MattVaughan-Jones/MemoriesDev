import { __assign } from "tslib";
import { invariant, __DEV__ } from "../../utilities/globals/index.js";
import { useRef, useCallback, useMemo, useEffect, useState } from 'react';
import { ApolloError } from "../../core/index.js";
import { isNonEmptyArray } from "../../utilities/index.js";
import { useApolloClient } from "./useApolloClient.js";
import { DocumentType, verifyDocumentType } from "../parser/index.js";
import { useDeepMemo, useStrictModeSafeCleanupEffect, __use } from "./internal/index.js";
import { useSuspenseCache } from "./useSuspenseCache.js";
import { canonicalStringify } from "../../cache/index.js";
export function useSuspenseQuery(query, options) {
    if (options === void 0) { options = Object.create(null); }
    var client = useApolloClient(options.client);
    var suspenseCache = useSuspenseCache(options.suspenseCache);
    var watchQueryOptions = useWatchQueryOptions({ query: query, options: options });
    var variables = watchQueryOptions.variables;
    var _a = options.queryKey, queryKey = _a === void 0 ? [] : _a;
    var cacheKey = [client, query, canonicalStringify(variables)].concat(queryKey);
    var queryRef = suspenseCache.getQueryRef(cacheKey, function () {
        return client.watchQuery(watchQueryOptions);
    });
    var _b = useState(function () { return new Map([[queryRef.key, queryRef.promise]]); }), promiseCache = _b[0], setPromiseCache = _b[1];
    var promise = promiseCache.get(queryRef.key);
    if (!promise) {
        promise = queryRef.promise;
        promiseCache.set(queryRef.key, promise);
    }
    useTrackedQueryRefs(queryRef);
    useEffect(function () {
        return queryRef.listen(function (promise) {
            setPromiseCache(function (promiseCache) {
                return new Map(promiseCache).set(queryRef.key, promise);
            });
        });
    }, [queryRef]);
    var result = __use(promise);
    var fetchMore = useCallback(function (options) {
        var promise = queryRef.fetchMore(options);
        setPromiseCache(function (previousPromiseCache) {
            return new Map(previousPromiseCache).set(queryRef.key, promise);
        });
        return promise;
    }, [queryRef]);
    var refetch = useCallback(function (variables) {
        var promise = queryRef.refetch(variables);
        setPromiseCache(function (previousPromiseCache) {
            return new Map(previousPromiseCache).set(queryRef.key, promise);
        });
        return promise;
    }, [queryRef]);
    var subscribeToMore = useCallback(function (options) { return queryRef.observable.subscribeToMore(options); }, [queryRef]);
    return useMemo(function () {
        return {
            client: client,
            data: result.data,
            error: toApolloError(result),
            networkStatus: result.networkStatus,
            fetchMore: fetchMore,
            refetch: refetch,
            subscribeToMore: subscribeToMore,
        };
    }, [client, fetchMore, refetch, result, subscribeToMore]);
}
function validateOptions(options) {
    var query = options.query, fetchPolicy = options.fetchPolicy, returnPartialData = options.returnPartialData;
    verifyDocumentType(query, DocumentType.Query);
    validateFetchPolicy(fetchPolicy);
    validatePartialDataReturn(fetchPolicy, returnPartialData);
}
function validateFetchPolicy(fetchPolicy) {
    if (fetchPolicy === void 0) { fetchPolicy = 'cache-first'; }
    var supportedFetchPolicies = [
        'cache-first',
        'network-only',
        'no-cache',
        'cache-and-network',
    ];
    invariant(supportedFetchPolicies.includes(fetchPolicy), 56, fetchPolicy);
}
function validatePartialDataReturn(fetchPolicy, returnPartialData) {
    if (fetchPolicy === 'no-cache' && returnPartialData) {
        __DEV__ && invariant.warn(57);
    }
}
export function toApolloError(result) {
    return isNonEmptyArray(result.errors)
        ? new ApolloError({ graphQLErrors: result.errors })
        : result.error;
}
export function useTrackedQueryRefs(queryRef) {
    var trackedQueryRefs = useRef(new Set());
    trackedQueryRefs.current.add(queryRef);
    useStrictModeSafeCleanupEffect(function () {
        trackedQueryRefs.current.forEach(function (sub) { return sub.dispose(); });
    });
}
export function useWatchQueryOptions(_a) {
    var query = _a.query, options = _a.options;
    var watchQueryOptions = useDeepMemo(function () { return (__assign(__assign({}, options), { query: query, notifyOnNetworkStatusChange: false, nextFetchPolicy: void 0 })); }, [options, query]);
    if (__DEV__) {
        validateOptions(watchQueryOptions);
    }
    return watchQueryOptions;
}
//# sourceMappingURL=useSuspenseQuery.js.map