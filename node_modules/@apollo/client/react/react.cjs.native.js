'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

require('../utilities/globals');
var context = require('./context');
var hooks = require('./hooks');
var parser = require('./parser');
var trie = require('@wry/trie');
var utilities = require('../utilities');
var tslib = require('tslib');
var core = require('../core');

var QueryReference = (function () {
    function QueryReference(observable, options) {
        var _this = this;
        var _a;
        this.listeners = new Set();
        this.initialized = false;
        this.refetching = false;
        this.listen = this.listen.bind(this);
        this.handleNext = this.handleNext.bind(this);
        this.handleError = this.handleError.bind(this);
        this.dispose = this.dispose.bind(this);
        this.observable = observable;
        this.result = observable.getCurrentResult(false);
        this.key = options.key;
        if (options.onDispose) {
            this.onDispose = options.onDispose;
        }
        if (core.isNetworkRequestSettled(this.result.networkStatus) ||
            (this.result.data &&
                (!this.result.partial || this.observable.options.returnPartialData))) {
            this.promise = utilities.createFulfilledPromise(this.result);
            this.initialized = true;
            this.refetching = false;
        }
        this.subscription = observable.subscribe({
            next: this.handleNext,
            error: this.handleError,
        });
        if (!this.promise) {
            this.promise = new Promise(function (resolve, reject) {
                _this.resolve = resolve;
                _this.reject = reject;
            });
        }
        this.autoDisposeTimeoutId = setTimeout(this.dispose, (_a = options.autoDisposeTimeoutMs) !== null && _a !== void 0 ? _a : 30000);
    }
    QueryReference.prototype.listen = function (listener) {
        var _this = this;
        clearTimeout(this.autoDisposeTimeoutId);
        this.listeners.add(listener);
        return function () {
            _this.listeners.delete(listener);
        };
    };
    QueryReference.prototype.refetch = function (variables) {
        this.refetching = true;
        var promise = this.observable.refetch(variables);
        this.promise = promise;
        return promise;
    };
    QueryReference.prototype.fetchMore = function (options) {
        var promise = this.observable.fetchMore(options);
        this.promise = promise;
        return promise;
    };
    QueryReference.prototype.dispose = function () {
        this.subscription.unsubscribe();
        this.onDispose();
    };
    QueryReference.prototype.onDispose = function () {
    };
    QueryReference.prototype.handleNext = function (result) {
        if (!this.initialized || this.refetching) {
            if (!core.isNetworkRequestSettled(result.networkStatus)) {
                return;
            }
            if (this.result.data && result.data === void 0) {
                result.data = this.result.data;
            }
            this.initialized = true;
            this.refetching = false;
            this.result = result;
            this.resolve(result);
            return;
        }
        if (result.data === this.result.data) {
            return;
        }
        this.result = result;
        this.promise = utilities.createFulfilledPromise(result);
        this.deliver(this.promise);
    };
    QueryReference.prototype.handleError = function (error) {
        var result = tslib.__assign(tslib.__assign({}, this.result), { error: error, networkStatus: core.NetworkStatus.error });
        this.result = result;
        if (!this.initialized || this.refetching) {
            this.initialized = true;
            this.refetching = false;
            this.reject(error);
            return;
        }
        this.result = result;
        this.promise = result.data
            ? utilities.createFulfilledPromise(result)
            : utilities.createRejectedPromise(result);
        this.deliver(this.promise);
    };
    QueryReference.prototype.deliver = function (promise) {
        this.listeners.forEach(function (listener) { return listener(promise); });
    };
    return QueryReference;
}());

var SuspenseCache = (function () {
    function SuspenseCache(options) {
        if (options === void 0) { options = Object.create(null); }
        this.queryRefs = new trie.Trie(utilities.canUseWeakMap);
        this.options = options;
    }
    SuspenseCache.prototype.getQueryRef = function (cacheKey, createObservable) {
        var ref = this.queryRefs.lookupArray(cacheKey);
        if (!ref.current) {
            ref.current = new QueryReference(createObservable(), {
                key: cacheKey,
                autoDisposeTimeoutMs: this.options.autoDisposeTimeoutMs,
                onDispose: function () {
                    delete ref.current;
                },
            });
        }
        return ref.current;
    };
    return SuspenseCache;
}());

exports.ApolloConsumer = context.ApolloConsumer;
exports.ApolloProvider = context.ApolloProvider;
exports.getApolloContext = context.getApolloContext;
exports.resetApolloContext = context.resetApolloContext;
exports.DocumentType = parser.DocumentType;
exports.operationName = parser.operationName;
exports.parser = parser.parser;
exports.SuspenseCache = SuspenseCache;
for (var k in hooks) {
    if (k !== 'default' && !exports.hasOwnProperty(k)) exports[k] = hooks[k];
}
//# sourceMappingURL=react.cjs.map
